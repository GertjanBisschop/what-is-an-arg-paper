\documentclass{article}
\usepackage[round]{natbib}
\usepackage{amsmath,amssymb,amsfonts}%
\usepackage{geometry}%
\usepackage{color}
\usepackage{graphicx}
\usepackage{authblk}
\usepackage{nameref}
\usepackage[right]{lineno}

\usepackage{subcaption}
\usepackage{tikz}
\usetikzlibrary{calc,positioning}

\begin{document}

\linenumbers
\title{What is an Ancestral Recombination Graph?}
% First authors
\author{Author McAuthorface}
% Corresponding

\maketitle

% JK: this is a rough first pass for a slightly different paper. Needs
% substantial revision.
\begin{abstract}
It has recently become possible to infer genetic ancestry in the presence of
recombination at scale for the first time, enabling many
downstream applications in population and statistical genetics.
Such recombinant genetic ancestry is usually
referred to as an Ancestral Recombination Graph, or ARG.
% Note: slight repetition here with first sentence.
There are now multiple methods that can infer ARGs at a practical scale
and it is therefore vital that these methods can be systematically evaluated
and compared to determine their strengths and weaknesses.
Unfortunately, however, there is substantial confusion over
terminology and little agreement on shared standards for data interchange,
significantly hampering progress in this important area.
This confusion and lack of agreement on basic issues such as what does and
does not constitute an ARG is partly attributable to the historical
development of the term.
Originally rigorously defined as
a representation of the coalescent with recombination
stochastic process as a graph, an ARG is now understood to refer to any
concrete realisation of a recombinant genetic ancestry.
We show that the standard description of an ARG
in terms of common ancestor and recombination events
(inherited from the original stochastic process definition) is
ambiguous, fundamentally limited and an unsuitable basis for data interchange.
We provide a simple alternative definition of an ARG in which a node
corresponds to one of an individuals monoploid genomes, an edge
% jk-note: this is clumsy
defines a genetic ancestry relationship between two nodes,
and annotations on those edges define the precise patterns of
ancestry in intervals along the genome.
We use this framework to define some classifications and metrics of ARG nodes,
and discuss the properties of some recently developed inference methods.
% jk-note: this ends a bit flat - we should say other stuff like we clarify
% how the ARG relates the pedigree, etc, etc. Let's go through again when
% we have a reasonable draft.
\end{abstract}

\textbf{Keywords:} Ancestral Recombination Graphs

\section*{Introduction}
Inferring the genetic relationships between sampled genomes in the form of an
evolutionary tree is a necessary prerequisite for many analyses of non (or
rarely) recombining organisms [refs]. The trees capture what is known and
knowable about the genetic ancestry of the sample in an elegant and concise
way, by postulating a set of nodes that are ancestors common to the samples,
and the ancestral relationships between those nodes. A rich literature exists
on analysing the mathematical properties of these trees [cite?], and numerous
methods exist to infer them~\citep{felsenstein2004inferring}. The situation is
quite different in recombining organisms, where the analysis of genetic data
depends on summaries ultimately derived from the trees such as allele
% TODO cite the other papers that preceded ralph2020efficiently here.
frequencies~\citep{ralph2020efficiently}, site frequency spectra, patterns of linkage
disequilibrium~\citep{mcvean2002genealogical} and principal
components~\citep{mcvean2009genealogical}. Genealogical analysis is equally
fundamental to the study of recombining organisms, but profound technical
difficulties have made the routine inference of recombinant genealogies
impossible, and therefore tree-based analysis methods have been largely
unavailable to the fields of population and statistical genetics.

Recent breakthroughs large-scale inference
methods~\citep{rasmussen2014genome,kelleher2019inferring,speidel2019method,
schaefer2021ancestral,wohns2021unified}
and data representation~\citep{kelleher2016efficient}
have raised the genuine prospect of genealogical analysis becoming a standard part
of the population and statistical genetics toolkit.
Applications using these inferred ancestries as input have
begun to appear~\citep{osmond2021estimating} and many more are sure to
follow~\citep{harris2019database}. This vibrant research area, however,
has a significant difficulty, which, if not addressed, will substantially hamper
progress. We currently lack a well-defined data-model and shared terminology
to discuss recombining genealogies,
leading to basic errors in statements about what different inference methods
produce as output (see the XXX section below), as well as presenting serious
difficulties in either comparing the outputs of different methods or
(from a users perspective) using multiple inference methods in an analysis.

In this paper we [turn into proper round up paragraph later]
\begin{enumerate}
\item Discuss the classical Ancestral Recombination Graph formulation,
and show how it derives from (and is limited by) the coalescent with
recombination.
\item Suggest a definition of ARGs that is free of these limitations,
where the formulation is derived from a diploid pedigree rather than
the coalescent approximations and spatial annotations are attached to
edges rather than nodes.
\item Suggest a classification of ARG nodes that helps us to understand
the properties of the structures inferred by different methods, and illustrate
with some examples.
\end{enumerate}

\section*{Ancestral recombination graphs}
The coalescent~\citep{kingman1982coalescent,kingman1982genealogy,
hudson1983testing, tajima1983evolutionary}
provides the theoretical underpinning for much of contemporary population genetics.
Hudson extended the coalescent to include
recombination~\citep{hudson1983properties,hudson1990gene}
and the model has proved to be especially powerful basis for
simulations~\citep{hudson2002generating,kelleher2016efficient,kelleher2020coalescent,
baumdicker2021efficient}.
Hudson's algorithm is concerned with simulating the process of
the coalescent with recombination as efficiently as possible, and operates by
tracking segments of ancestral material carried by ancestors as
we go backwards in time. The details of Hudson's algorithm and how the
results of the ancestral process are represented are critical to later
discussions, and so we will explain the process in some detail.
See~\cite{kelleher2016efficient} for a more detailed
description of the algorithm, and how it may be implemented efficiently.

Hudson's algorithm operates by tracking the state of a set of ancestral
lineages as we go backwards in time. Each lineage consists of a list of
disjoint ancestry segments $(\ell, r, a)$, where
$[\ell, r)$ is a half-closed genomic interval and $a$ is an integer
tracking the number of samples the lineage is ancestral to over the interval.
(We also usually track the tree node associated with each segment, but
that is not important for our purposes here so we omit it.)
If we have $n$ samples and genome of length $L$, the process begins with $n$ lineages
of the form $[(0, L, 1)]$. The process then works backwards in time from
the present day as a series of random common ancestor or recombination events.
Recombination events occur at a rate determined by the amount and spatial
distribution of ancestral material among lineages.
Let $A$ be the set of ancestors at a given time $t$. Recombination events
happen at rate $\rho \nu / (L - 1)$ where
\[
\nu = \sum_{x \in A}\left( \max_{(\ell, r, a) \in x}r
    - \min_{(\ell, r, a) \in x}\ell - 1 \right)
\]
is the number of available `links' that may be broken. Thus, the rate of
recombination is determined by the left and right-most extent of the
ancestral material carried by each lineage. At a recombination
event we choose one of these links uniformly and break it. Given a lineage
$x = [(\ell_j, r_j, a_j)]$ and a breakpoint $k$, we have two lineages
$x_1$ and $x_2$ such that FILL IN DETAILS

When $k = |A|$ lineages are present, common ancestor events
occur at rate $k(k - 1) / 2$. In a common ancestor event two lineages
are chosed uniformly at random and their ancestry segments merged.
If we have overlapping intervals of ancestry from the two lineages,
say, $(\ell, r, a_1)$ and $(\ell, r, a_2)$, a
\emph{coalescence} occurs and ancestor represented by the current event
will be present as a node (at least) in the marginal trees covering
the interval $[\ell, r)$. The result of this coalescence is a segment
$(\ell, r, a_1 + a_2)$, and if $a_1 + a_2 < n$ it is included in the
ancesty for the new lineage. Otherwise, if $a_1 + a_2 = n$ we know that
we have found the most recent common ancestor of all samples in
the interval $[\ell, r)$ and so we do not need to simulate its history any further.
Nonoverlapping intervals of ancestry from the two lineages are included
in the resulting lineage without changes. Eventually, as the process continues,
we find resultant lineages in which all segments have fully coalescenced,
and so the number of extant lineages gradually dwindles down to zero.

The Ancestral Recombination Graph (ARG) was later introduced
Griffiths~\citep{griffiths1991two,ethier1990two,griffiths1997ancestral}, and is a
closely related and complementary treatment of the same process. Where
Hudson's algorithm is focused on the efficient \emph{simulation} of the
process, the original ARG literature is focused on mathematical
results about the stochastic process. Griffiths and colleagues formulated the
ARG as a branching-coalescing stochastic process

NOTES for continuing:

\begin{itemize}
\item The ARG process does not track ancestral material. Recombination events
occur at rate $k \rho / 2$, and we don't complete until there's only one
lineage left. That means the process continues for an exponentially long time.
\item Discuss the way in which the re events work.
\item Discuss the rules for pulling out the trees. This is equivalent to doing
the interval logic above in Hudson's algorithm.
\end{itemize}

\section*{Ancestral graphs and stochastic processes}

% See https://github.com/tskit-dev/what-is-an-arg-paper/discussions/13
% for discussions on this section

The simplest prominent example of genetic ancestry generated by a stochastic process
is the coalescent process \citep{kingman1982coalescent,kingman1982genealogy,
hudson1983testing, tajima1983evolutionary}, which describes the random
ancestral tree at one non-recombining locus obtained by sampling a relatively
small number of individuals at random from a large population.

In a recombining organism, the genetic ancestry of a longer segment of DNA is
no longer described by a single tree. Instead, ancestral relationships in a
sample can be represented by a sequence of correlated, marginal trees along the
genome. The Ancestral Recombination Graph (ARG) was introduced by
Griffiths~\citep{griffiths1991two,griffiths1997ancestral} as a branching-coalescing
stochastic process whose realisations are graphs which into which all of the
marginal ancestral trees are embedded. Coalescences encode common ancestry
as they do in the coalescent, while branching events encode points at which a
marginal tree changes from one position along the genome to the next.
% jk-note: could nitpick this in that diamonds don't generate tree
% "changes" as such. Maybe tweak this on the next round of revision?

% jk-note: this isn't quite right I think, as it's muddling the
% distinction between a graph stochastic process
% definition with the graph as the encoding of the marginal trees.
There are several formulations of the ARG, which vary by
the amount of extra information they capture beyond a minimal representation
of all marginal trees. Two prominent examples are the ``big''
ARG~\citep{ethier1990two}, which has a particularly simple specification as a
stochastic process but is computationally infeasible, and the ``little ARG''
traversed by Hudson's algorithm~\citep{hudson1983properties}, which
has a more complex state space and dynamics but can be implemented with
a more manageable runtime and memory footprint. An efficient simulation
implementation has become available only recently \citep{kelleher2016efficient},
prior to which state-of-the-art simulators were based on the so-called sequentially
Markovian coalescent (SMC) \citep{mcvean2005approximating}, which delivers
performance gains by disallowing mergers which would result in trapped
non-ancestral material. An alternative restricted model is
\texttt{ClonalFrame}  \citep{didelot2007inference}, which fixes one distinguished
tree and disallows recombination in any other marginal tree.

Similar graph encodings have also been introduced to model other mechanisms
which change the local ancestral tree along the genome, such as gene
conversion~\citep{wiuf2000coalescent} and
horizontal gene transfer~\citep{baumdicker2014infinitely}.

The idea of using branching-coalescing stochastic processes
to model genetic ancestral trees has also found application in natural selection.
The Ancestral Selection Graph (ASG)~\citep{krone1997ancestral,neuhauser1997genealogy}
uses dynamics identical to the ``big" ARG to simulate an ensemble of correlated
potential ancestral trees. Weak genic selection is incorporated by sampling a
true ancestry from the ensemble in a non-uniform way.
There is no ASG analogue of the more computationally tractable ``little" ARG,
though some gains in tractability can be made by considering typed
lineages~\citep{etheridge2009coalescent} or by leveraging perfect simulation
techniques when recurrent mutation is present\citep{fearnhead2001perfect}.
Extensions of the ASG have been developed to frequency-dependent
selection~\citep{neuhauser1999ancestral, gonzalezcasanova2018duality},
unlinked chromosomes~\citep{fearnhead2003ancestral}, recombining
loci whereupon branching is due to both selection and
recombination~\citep{donnelly1999genealogical}, and high fecundity
reproduction~\citep{gonzalezcasanova2018duality, koskela2019robust}.


\begin{figure}
\centering
\begin{tikzpicture}[xscale=0.8, yscale=0.3, node distance=2mm and 20mm]
\tikzset{greynode/.style={circle,fill,inner sep=1},
nodelabel/.style={font=\footnotesize}}

\node (s0) [greynode] {};
\node (s1) [right=of s0,greynode] {};
\node (s2) [right=of s1,greynode] {};
\node [greynode] (s3) at ($(s1) + (0,1)$) {};
\node [greynode] (s4) at ($0.5*(s1) + 0.5*(s2) + (0,2)$) {};
\node [greynode] (s5) at ($0.5*(s0) + 0.5*(s1) + (0,3)$) {};
\node [greynode] (s6) at ($(s1) + (0,5)$) {};

\node [nodelabel,anchor=north west] at ($(s3) + (0,0)$) {$x = 0.3$};
\foreach \u/\lab in {s0/0, s1/1, s2/2} \node[nodelabel,anchor=north] at (\u) {\lab};
\foreach \u/\lab in {s4/4} \node[nodelabel,anchor=south west] at (\u) {\lab};
\foreach \u/\lab in {s5/5} \node[nodelabel,anchor=south east] at (\u) {\lab};
\foreach \u/\lab in {s3/3, s6/6} \node[nodelabel,anchor=south] at (\u) {\lab};

%% Edges
\draw (s1) -- (s3);
\foreach \child/\parent in {s6/s5, s6/s4, s5/s0, s4/s2}
	\draw (\child) -| (\parent);

\draw (s5) -| ($0.5*(s3) + 0.5*(s3-|s5)$) |- (s3);
\draw (s4) -| ($0.5*(s3) + 0.5*(s3-|s4)$) |- (s3);

\end{tikzpicture}
\caption{\label{fig-arg} \textcolor{red}{A picture of a standard ARG for us
to work with for now. We should replace it with something better at some
point.}
 }
\end{figure}



\section*{The ARG as a structure}

\citep[e.g.][]{minichiello2006mapping,mathieson2020ancestry}.

\begin{figure}
\vspace{5em}
\caption{\label{fig-pedigree-and-arg}
The (unannotated) ARG is closely related to the pedigree
graph, where each ``individual'' node is replace by two ``genome''
nodes, and edges between parents and children are only included if there is
transfer of ancestral material. We usually only include nodes in an ARG
that affect our sample, so that, for example, individuals that are ancestral
to only one sampled genome are not included.}
\end{figure}


% HYW: this is a rough first pass. We should take care not to assume that the tree sequence
% approach is the only encoding

The other use of the the term ARG, and the one for which we suggest the term be
reserved, is to describe the *structure* resulting from the genetic process of
inheritance. This structure, like any other graph, consists of *nodes*
connected by *edges*. In the context of genetics, the nodes represent (haploid)
genomes, and the edges represent paths of inheritance. Although for theoretical
purposes a graph like this can be created by backwards-in-time simulations
using the CwR, in reality it is created forwards-in-time, as a population
evolves.

Since genetic inheritance is unidirectional, the edges in this graph structure
are *directed*, with a "parent" and "child" node. Moreover, there is a strict
temporal order, so that children cannot be their own parents: in other words,
there are no cycles in the graph, and it is technically a form of "directed
acyclic graph" (DAG).

% HYW: NB: worded carefully below, as it should also be possible to encode ARGs even if there is not a single fixed coordinate system

There is one key feature which distinguishes an ARG for other graphs. Although
a genome (graph node) may have more than one parent, the particulate nature of
genetic inheritance means that each letter in the genome can only come from a
*single* parent. Hence if we compare the equivalent letters from multiple
extant genomes, their paths of inheritance must form a *tree* (which,
incidentally, is why phylogenetics plays such an important role in evolutionary
theory). As we shall argue, the ability to generate these "local trees" from an
ARG is of key importance.

When describing an ARG, the primary issue, from a practical point of view, is
how to annotate the graph with the details of which piece of genome has come
from which parent. There are two possibilities: the annotations can be
associated either with the nodes, or with the edges.

\begin{figure}
\vspace{5em}
% NB: not clear if this figure is better off on its own or should be
% merged with the pedigree one.
\caption{\label{fig-arg-annotations}
The specific path through the ARG for a given genome position (and therefore
the local genealogical tree) cannot be determined without annotations
to the graph. (A) The classical Griffiths approach annotates recombination
nodes with the corresponding breakpoint. (B) We can equivalently
annotate the \emph{edges} with the genomic intervals carrying ancestral
material. Edge annotations are somewhat more general, and have
significant computational advantages.}
\end{figure}

\subsection*{Node annotated recombination}

In the original (Griffiths) formulation, nodes which have multiple parents are
annotated with a breakpoint, representing a genomic position. The genome
lying to the left of that position is then taken to come from one parent, while
the genome lying to the right is taken to come from the other parent. This is
an elegantly concise encoding of the parental source, and is used, for example
in the ARGweaver .arg format. However, it suffers from three principal
drawbacks:


1. It assumes only a single breakpoint per node: problematic for representing
e.g. gene conversion or multiple chromosomes (but this could be circumvented by
having multiple breakpoints)
2. Nodes can only have a maximum of 2 parents. At
first sight, this seems a reasonable limitation, but it turns out that it can
be helpful to collapse multiple nodes into one, which potentially results in
more than two parents for any given node (see section XXXX)
3. Generating local
trees from such an encoding is time consuming (XXX describe *how* time
consuming - i,e. scaling properties with number of nodes - and why this is,
theoretically)

\subsection*{Edge annotated recombination}

An alternative approach to annotating nodes with the parent of origin of each
section of genome is to annotate each edge with the genomic region which is
inherited via that route. This approach was first introduced by Kelleher et al
(cite msprime paper) and now forms the basis of a comprehensive software
library.

% HYW: should discuss the link to biology & mitosis/meiosis: a "node" is
% strictly a cell - it is shorthand to associate it with an "individual"

\begin{figure}
\centering
\vspace{5em}
\includegraphics[width=\linewidth]{illustrations/ARG_recomb_node_deletion}
\caption{\label{fig-recombinati on-nodes}
Recombination nodes are optional in an edge-annotated ARG. (a) A simulated
ARG including all recombination nodes (red). (b) The same ARG having removed both
recombination nodes and nodes of common ancestors in which no genetic
lineages coalesce (cyan). (c) The sequence of trees corresponding to (b): if we were
to plot out the trees corresponding to (a) we would have more trees, but the topologies
and MRCA nodes at each genomic location would be identical. For clarity, nodes are
plotted by ranked time rather than true time on the y-axis.
% HYW: note that we also truncate nodes for portions in which they are unary,
% so that nodes which are coalescent nodes over only some of their length
% (blue-green) become coalescent nodes over their entire length (green). This
% can, however, throw away some useful information, for example node 4 has
% only a single parent edge in (a), but 2 parent edges (one of which appears
% to bypass node 11) in (b). In fact, this edge should go through node 11, but
% there may be no way to detect this from real data.
}
\end{figure}


\section*{ARG inference methods}
Using the terminology developed here to classify ARGs, we review methods developed
to infer ARGs. We focus our attention on some recent methods and discuss the
properties of the ARGs inferred.

The ARG has been used as a model for recombining DNA sequence data essentially
since it was first formulated. Early methods focused on finding parsimonious
ARGs consistent with a given set of
sequences \citep{hein1990reconstructing, lyngso2005minimum}.
However, identifying the most parsimonious ARG for a given sequence data set
is NP-hard \citep{wang2001perfect}, and subsequent methods have resorted to
various heuristics \citep{fallon2013acg, hein1993heuristic, ignatieva2021kwarg,
kelleher2019inferring, minichiello2006mapping, mirzaei2017rent,
parida2008estimating, song2005efficient, thao2019hybrid, zhang2021biobank}.
The scalability of these methods varies substantially based on the heuristic in use
and the underlying data structure, but the most efficient methods can be practically
used on megabase scale data and tens of thousands of samples under human-like
parameters \citep{kelleher2019inferring, zhang2021biobank}.

An alternative approach is to treat the ancestry as a latent parameter to be averaged out
by Monte Carlo methods, based either on importance sampling
\citep{griffiths1996ancestral, fearnhead2001estimating, jenkins2011inference}
or MCMC \citep{kuhner2000maximum, nielsen2000estimation, wang2008bayesian}.
These methods invariably operated on a representation of the ``little ARG", typically
generated until the grand MRCA. They are extremely computationally expensive,
and applicable to at most hundreds of samples consisting of tens of kilobases with
human-like parameters.

Due to the computational expense of sampling ``little ARGs", state-of-the-art
Monte Carlo methods typically rely on cheaper, approximate models.
The most prominent examples are \texttt{ARGWeaver} \citep{rasmussen2014genome}
and \texttt{Arbores} \citep{heine2018bridging}. The former also utilises a time
discretisation approximation, but scales to dozens of mammal-like genomes.
The \texttt{ClonalOrigin} method \citep{didelot2010inference,
medinaaguayo2020speeding} uses the \texttt{ClonalFrame}
model and data structure, though it is not as scalable as \texttt{ARGWeaver}.

A very recent MCMC method called \texttt{ARGInfer} has resulted in the first
improvement in the scalability of Monte Carlo methods for the exact ARG model
by making use of the tree sequence representation of marginal trees, suitably enriched
to facilitate the computations needed for MCMC sampling \citep{mahmoudi2021inference}.
While not competitive with the scalability of \texttt{ARGWeaver}, \texttt{ARGInfer} extends
the feasible range of sequence lengths by at least an order of magnitude when
compared with methods which sample realisations of the exact ``little ARG".


\begin{figure}
\vspace{5em}
\caption{\label{fig-inferred-args}
ARGs inferred by different methods from a small dataset. Notes about these
ARGs.
}
\end{figure}

\section*{Discussion}

Discussion points (may or may not be used, certainly would be heavily revised)

\begin{itemize}
\item Terminology based around an inferred ancestry being a ``true''
ARG is impoverished and misleading. The only reasonable interpretation
of a ARG being true or not is whether it's a sample from the coalescent.
Most inference methods (and all that scale well) do not. In any case,
the coalescent is just one model, and a highly idealised one. It is
exceedingly unlikely that the actual ARG describing the ancestry
of any biological population is ``true'' ARG in this sense. The terminology is
impoverished because it reduces the possibilities available
to something either being an ARG or not, whereas there are many different
interesting properties of these structures that we should be able to
discuss and compare.
\item tskit can represent any ARG.
\end{itemize}

\bibliographystyle{plainnat}
\bibliography{paper}

\end{document}
